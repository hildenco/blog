#  Containers are new binaries
Containers are new binaries of deployment
- Steve Lasker, Principal Program Manager at Microsoft

This is a new reality you will face as a .NET developer: working with microservices.


# Adding Docker Support
Using Visual Studio, create a new ASP.NET Core Web application. When the application is loaded, either select Add Docker Support from the PROJECT menu or right-click on the project from the solution explorer and select Add Docker Support as shown in the following screenshot:

The following files are added to the project:

    * Dockerfile: The Docker file for ASP.NET Core applications is based on the microsoft/aspnetcore image. This image includes the ASP.NET Core NuGet packages, which have been prejitted, improving startup performance. When building ASP.NET Core applications, the Docker file FROM instruction (command) points to the most recent microsoft/dotnet image on the Docker hub.
    * Docker-compose.yml: This is the baseDocker-compose file used to define the collection of images to be built and run with Docker-compose build/run.
    * Docker-compose.dev.debug.yml: This is an additional Docker-compose file for iterative changes when your configuration is set to debug. Visual Studio will call -f docker-compose.yml and -f docker-compose.dev.debug.yml to merge them. This compose file is used by Visual Studio development tools.
    * Docker-compose.dev.release.yml: This is an additional Docker Compose file to debug your release definition. It will load the debugger in isolation so it does not change the content of production image. 

## Understanding the Commands
If we look at the file generated by Visual Studio, this is what we have:
```s
    FROM microsoft/aspnetcore:1.0.1
    ENTRYPOINT ["dotnet", "ProductCatalogService.dll"]
    ARG source=.
    WORKDIR /app
    EXPOSE 80
    COPY $source .
```

Let' now take a look at what each of these commands do:
    * FROM tells Docker that to pull the base image on the existing image, call microsoft/aspnetcore:1.0.1. This image already contains all the dependencies for running the ASP.NET Core on Linux, so we don't have to set it.
    * COPY and WORKDIR copy the current directory's contents to a new directory inside the called/app container and set it to the working directory for subsequent instructions.
    * EXPOSE tells Docker to expose the product catalog service on port 80 of the container.
    * ENTRYPOINT specifies the command to execute when the container starts up. In this case, it's .NET.

## Running the Image
Run and test the image in a live container. Now if you may have noticed in the last step, when you add Docker support to the ProductCatalogService project, Visual Studio adds Docker as an option in the run menu as well:

Now all you have to do is press F5 and launch your service in the container. This is the easiest way to put your service in the container. Once your microservice is containerized, you can use Visual Studio team services and Azure container services to deploy your container to the Azure cloud

# Container Security
Docker is a grand force around containerization of applications in the industry. With widespread usage of containers, it is evident that we need to have effective security measures around containers. If we take a look at the internal architecture of containers, they are quite close to the host operating system kernel.

Docker applies the principle of least privilege to provide isolation and reduce the attack surface. Despite the advances, the following points will help you understand the security measures you can take around containers:
    * Ensure all the container images used for microservices are signed and originate from a trusted registry
    * Harden the host environment, the daemon process, and images
    * Follow the principle of least privilege and do not elevate access to access devices
    * Use control groups in Linux to manage keeping a tab on resources, such as memory, I/O, and CPU
    * Even though containers live for a very short duration, logging all of the container activity is advisable and important to understand for post analysis
    * If possible, integrate the container scanning process with tools, such as aqua (http://www.aquasec.com) or Twistlock (https://www.twistlock.com)

# Summary
The microservice architectural style being distributed by design gives us better options to protect valuable business critical system. Traditional .NET-based authentication and authorization techniques are not sufficient and cannot be applied to the microservice world. We also saw why secure-token-based approaches, such as OAuth 2.0 and OpenID Connect 1.0, are becoming de facto standards for microservice authorization and authentication. If you want to have more general information related to security, do visit Open Web Application Security Project (OWASP) at http://www.owasp.org and Microsoft Security development life cycle at https://www.microsoft.com/en-us/sdl/. Azure AD can very well support OAuth 2.0 and OpenID Connect 1.0. Azure API Management can also act as an API gateway in microservices' implementation and also provide nifty security features, such as policies.

Azure AD and Azure API management provide quite a few powerful capabilities to monitor and log the requests received. This will be quite useful, not only for security but also for tracing and troubleshooting scenarios. We will see logging, monitoring, and the overall instrumentation around troubleshooting of microservices in the next chapter.


